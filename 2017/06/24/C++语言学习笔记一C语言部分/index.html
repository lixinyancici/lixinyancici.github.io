<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />





  <link rel="alternate" href="/atom.xml" title="StarrySky's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/myfavicon.ico?v=5.1.0" />






<meta name="description" content="学习材料是”C语言深度剖析”  补码按我自己的理解, 补码其实很简单, 就是一个用无符号数(状态)表示有符号数的过程,因为计算机底层0101本身就没符号的概念,所以将有符号数建立在无符号数基础上也很自然:                     128  |                   129      |      127             130          |">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++语言学习笔记一C语言部分">
<meta property="og:url" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/index.html">
<meta property="og:site_name" content="StarrySky's Blog">
<meta property="og:description" content="学习材料是”C语言深度剖析”  补码按我自己的理解, 补码其实很简单, 就是一个用无符号数(状态)表示有符号数的过程,因为计算机底层0101本身就没符号的概念,所以将有符号数建立在无符号数基础上也很自然:                     128  |                   129      |      127             130          |">
<meta property="og:image" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/运算符.png">
<meta property="og:image" content="c:/Users/StarrySky/Desktop/预处理易错点.jpg">
<meta property="og:image" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/预处理指令1.jpg">
<meta property="og:image" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/预处理指令2.jpg">
<meta property="og:image" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/linux_binary_memory.png">
<meta property="og:updated_time" content="2017-06-28T10:53:44.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++语言学习笔记一C语言部分">
<meta name="twitter:description" content="学习材料是”C语言深度剖析”  补码按我自己的理解, 补码其实很简单, 就是一个用无符号数(状态)表示有符号数的过程,因为计算机底层0101本身就没符号的概念,所以将有符号数建立在无符号数基础上也很自然:                     128  |                   129      |      127             130          |">
<meta name="twitter:image" content="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/运算符.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/"/>





  <title> C++语言学习笔记一C语言部分 | StarrySky's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">StarrySky's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/C++语言学习笔记一C语言部分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="StarrySky">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StarrySky's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++语言学习笔记一C语言部分
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T20:01:46+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>学习材料是”C语言深度剖析”</p>
</blockquote>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>按我自己的理解, 补码其实很简单, 就是一个用无符号数(状态)表示有符号数的过程,因为计算机底层0101本身就没符号的概念,所以将有符号数建立在无符号数基础上也很自然:<br>                     128  |  <em><br>                 129      |      127<br>             130          |          126<br>          131             |              125<br>             …          |           …<br>                 254      |      2<br>                     255  |  1<br>                          |  0<br>注: ‘</em>‘代表没有对应值, 同一行的两个数相加恒等于256(0除外);<br>如上图所示,我们以一个字节为例,也就是char类型, 竖线右边的值对应二进制最高位为0, 左边对应二进制最高位为1,  更宽的数据以此类推:</p>
<ul>
<li>当为unsigned char时: 数据范围从0逆时针到255,一共256种状态.</li>
<li>当为signed char/char时,数据范围从(-128) - 127, 竖线左边为负值对应的补码(其原码就是对应的竖线右边的那个值取负, 如254对应的原码就是-2), 右边为正值补码(正值的补码=原码)</li>
<li>对于8bits, 0-255就是所有的256中状态,计算机只存储0-255对应的二进制, 如果要用有符号, 我把左边解析成负数,右边解析成正数就行了.</li>
<li>有了上面的图解析过程就很简单了:<ul>
<li>从内存取出二进制值(补码) val;</li>
<li>当V的最高位为0时, 就把V的值作为解析结果;</li>
<li>当V的最高位为1时, 就把V-256的值作为解析结果;</li>
</ul>
</li>
<li>问题是第三步, 总不能为了解析一个数,再让CPU去做以此减法吧, 正好(~val)+1 &lt;=&gt; 256-val =&gt; val-256 &lt;=&gt; -((~val)+1) (~val是val的二进制按位取反), 按位取反对计算机来说那就so easy了.</li>
</ul>
<h2 id="C语言32个关键字"><a href="#C语言32个关键字" class="headerlink" title="C语言32个关键字:"></a>C语言32个关键字:</h2><p><strong>数据存储类别</strong> : auto static register extern<br><strong>基本数据类型</strong> : void char int float double<br><strong>类型修饰符</strong> : short long signed unsigned<br><strong>类型限定符</strong> : const volatile<br><strong>组合数据类型</strong> : struct union enum<br><strong>控制语句</strong> : if else do while for switch case default break continue goto return<br><strong>其它</strong> : typedef sizeof</p>
<h3 id="数据存储类别指示符"><a href="#数据存储类别指示符" class="headerlink" title="数据存储类别指示符:"></a>数据存储类别指示符:</h3><p>C语言声明变量有存储类型指示符：extern, static, auto, register,不指定时编译器根据约定自动取缺省值auto。<br>存储类型指示符的位置是任意的，仅对于存储类型指示符而言：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> i &lt;=&gt; <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> i</div></pre></td></tr></table></figure></p>
<p>C语言规范中，进行语法分析的时候，<strong>typedef和数据存储类别指示符是等价的</strong>, 仅对于typedef而言：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typedef const int i &lt;=&gt; const typedef int i &lt;=&gt;</div><div class="line">int const typedef i &lt;=&gt; const int typedef i</div></pre></td></tr></table></figure></p>
<p><strong>typedef不能和static等存储类型指示符同时使用，因为每种变量只能有一种存储类型</strong>.</p>
<h4 id="1-static-静态变量"><a href="#1-static-静态变量" class="headerlink" title="1. static(静态变量):"></a>1. static(静态变量):</h4><ul>
<li>修饰<strong>局部变量</strong>,扩展其生存期到整个程序生存期,但变量作用域不变,作用域外无法访问,位于静态存储区;</li>
<li>修饰<strong>全局变量</strong>或<strong>函数</strong>,限制其作用域,由整个程序或者项目到仅限于所在cpp文件(对应于内部链接);</li>
<li>[C++]修饰<strong>类的的数据成员</strong>和<strong>成员函数</strong>,表示数据唯一性,即该数据成员或者成员函数属于类而不是某个对象.<blockquote>
<p>注: <strong>linkage(链接性)</strong>: 描述某个标识符(或名称)在整个程序或者某个源文件中能否绑定到同一实体(某块内存,如具体的变量以及函数体等)<br><strong>无链接性:</strong><br>  局部变量(包括类的非静态成员), 函数形参.<br><strong>内部链接(internal linkage)</strong>: 标识符只能绑定到某个编译单元(预处理后的某个源码文件)内部的实体,不能跨编译单元:<br>  a. 静态全局变量, 全局const常量(C++,C中还是外部链接);<br>  b. inline函数(自由函数和类成员函数), 静态自由函数;<br><strong>外部链接(external linkage)</strong>:标识符可以跨编译单元绑定到某一实体:<br>  a. 非静态全局变量, 类的静态数据成员;<br>  b. 非静态自由函数,类成员函数和类静态成员函数;</p>
</blockquote>
</li>
</ul>
<h4 id="2-extern-声明其具有外部链接属性-同static相反"><a href="#2-extern-声明其具有外部链接属性-同static相反" class="headerlink" title="2. extern(声明其具有外部链接属性,同static相反):"></a>2. extern(声明其具有外部链接属性,同static相反):</h4><ul>
<li>声明本编译单元中的全局变量(一般用于全局变量定义之前使用该全局变量)</li>
<li>声明其它源文件中的全局变量(注意这里的源文件是指cpp文件,不是头文件,头文件直接include就行了,不需要用extern);</li>
<li>extern与const同时使用,表示具有外部链接属性的常量.  </li>
<li><strong>extern “C” {}</strong>:用于C++代码,告诉编译器{}中的代码编译时不做名称改写,防止由于C++的名称改写而导致的连接错误;一般用于C语言写的库(要在头文件的声明中使用),并且允许它用于C++语言时.  </li>
</ul>
<h3 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符:"></a>类型限定符:</h3><h4 id="1-const-只读变量"><a href="#1-const-只读变量" class="headerlink" title="1. const(只读变量):"></a>1. const(只读变量):</h4><ul>
<li>实质还是变量,只是不能修改(C中可通过指针间接修改); </li>
<li>C中不能用const变量来指定数组元素个数,但C++中可以;</li>
<li><p>分析const的作用对象时,忽略基本类型说明符即可,所以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i; &lt;=&gt; <span class="keyword">int</span> <span class="keyword">const</span> i;</div></pre></td></tr></table></figure>
</li>
<li><p>可以用来说明只读数组;</p>
</li>
<li><p><strong>修饰指针:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p; <span class="comment">// =&gt; const (*p) &lt;= 指针指向的内存不可修改</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p; <span class="comment">// =&gt; const (*p) &lt;= 指针指向的内存不可修改</span></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p; <span class="comment">// =&gt; * (const p) &lt;= 指针变量本身的值不可修改</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p; <span class="comment">// =&gt; const (* (const p)) &lt;=  指针变量本身和指针指向的内存都不可修改</span></div></pre></td></tr></table></figure>
</li>
<li><p>修饰函数参数: 防止实参被函数修改</p>
</li>
<li>修饰函数返回值: 返回值不可被改变,一般用于返回引用的函数,防止外部修改被引用的变量.</li>
<li>const与#define<br>编译器不会为const只读变量分配存储空间,而是放在符号表中,效率高, const定义的只读变量从汇编角度来看,只是给出了对应的内存地址, 而不是像define一样给出的是立即数,const只读变量在程序运行期间只有一份拷贝, 因为它是全局只读变量, 存放在静态区:<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 <span class="comment">// 宏常量</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>; <span class="comment">// 此时未将N放入内存中</span></div><div class="line"><span class="comment">// ... main ...</span></div><div class="line"><span class="keyword">int</span> I = M; <span class="comment">// 预编译期间进行宏替换，分配空间</span></div><div class="line"><span class="keyword">int</span> J = M; <span class="comment">// 再进行宏替换，又一次分配内存</span></div><div class="line"><span class="keyword">int</span> i = N; <span class="comment">// 此时为N分配内存，以后不再分配！</span></div><div class="line"><span class="keyword">int</span> j = N; <span class="comment">// 没有内存分配</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-volatile-关闭优化-让编译器老老实实按语句的意思来编译"><a href="#2-volatile-关闭优化-让编译器老老实实按语句的意思来编译" class="headerlink" title="2. volatile(关闭优化,让编译器老老实实按语句的意思来编译):"></a>2. volatile(关闭优化,让编译器老老实实按语句的意思来编译):</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[global] <span class="keyword">int</span> i = <span class="number">0</span>;   |         |</div><div class="line">[local]  i = <span class="number">20</span>;      |         |  </div><div class="line">                      | &lt;====== |     i = <span class="number">5</span>; <span class="comment">// 端口状态发生改变</span></div><div class="line">         <span class="keyword">int</span> j = i;   |         |</div><div class="line">         <span class="keyword">int</span> k = i;   |         |</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>= 20;``` 从内存中取出i的值赋值给i;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">```int j = i;``` 使用前面取出的值而不是重新从内存读取值,如果此时端口值(i)发生变化,那此处使用的i就不是i的真实值; 如果把```int i = 0``` 改为 ```volatile int i = 0```,那编译器就不会对i做优化,此时会从内存中重新读取i的值,然后给j赋值. </div><div class="line"></div><div class="line"></div><div class="line">### 组合数据类型:</div><div class="line">#### 1. 结构体(struct):</div><div class="line">* 空结构体大小为1;</div><div class="line">* **柔性数组**:当结构体的**最后一个元素(并且不是第一个,前面有其它成员)**是数组时,允许它不指定大小,即它的大小是可变的,成为柔性数组</div><div class="line">    - sizeof带柔性数组的结构体,大小不包括柔性数组大小;</div><div class="line">    - 带柔性数组的结构体需要用malloc进行内存分配,并且分配的大小要大于结构体大小,多出来的部分就是柔性数组的大小;   </div><div class="line"></div><div class="line">#### 2. 结构体的内存对齐:</div><div class="line">默认情况下，为了方便对对结构体内元素的访问与管理，当结构体内的元素长度都小于处理器的位数时，便以结构体里最长的元素为其单位，即结构体的长度一定是最长数据元素的整数倍；</div><div class="line">如果结构体里最长元素的内存长度大于处理器位数，就以处理器的位数为对齐单位。</div><div class="line">并不是处理器位数，是看**操作系统的位数**</div><div class="line">```C</div><div class="line">// manjaro x86_64 -&gt; 64 bits = 8 bytes</div><div class="line">struct foo1 &#123;                       | base_addr: 0</div><div class="line">    char *p; // 8 bytes             | offset: 0</div><div class="line">    char c;  // 1 bytes             | offset: 8</div><div class="line">//  char pad[7] // padding 7 bytes  |</div><div class="line">    long x;  // 8 bytes             | offset: 16</div><div class="line">&#125;;</div><div class="line">// total 24 bytes</div><div class="line"></div><div class="line">struct foo3 &#123;</div><div class="line">    int i; // 4 bytes (min(4,8) = 4)</div><div class="line">    char c; // 1 bytes</div><div class="line">/*  char pad[3]  */ // 结构体的尾填充 3 bytes</div><div class="line">&#125;;</div><div class="line">// total: 8 bytes</div></pre></td></tr></table></figure>
<p>foo5和foo6中的最长元素长度是int的长度（换句话说看的是类型长度，不是变量长度），所以foo5和foo6的长度一定是4的整数倍。<br>对于位域，比如foo6中a和b的类型是int，占4个字节，而a、b只占去了1个字节，占去的是这四个字节中的低位字节，也就是说，位域是通过偏移来实现的，而这个偏移是从低位向高位偏移，即a占据低位的0-4bits，b占据低位的5-7bits;<br>对于位域,我觉得只要把它以bytes为基本单位来分析,同时时刻铭记它是在一个内存模型(数据类型)中即可.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> foo5 &#123;</div><div class="line">    <span class="keyword">short</span> s;      <span class="comment">// 2 bytes</span></div><div class="line">    <span class="keyword">char</span> c;       <span class="comment">// 1 bytes</span></div><div class="line">    <span class="keyword">int</span> flip:<span class="number">1</span>;   <span class="comment">// 1 bits</span></div><div class="line">    <span class="keyword">int</span> nybble:<span class="number">4</span>; <span class="comment">// 4 bits</span></div><div class="line">    <span class="keyword">int</span> pad1:<span class="number">3</span>;   <span class="comment">// padding 3 bits // 用来与char c对齐,看成一个独立的bytes</span></div><div class="line">    <span class="keyword">int</span> septet:<span class="number">7</span>; <span class="comment">// 7 bits</span></div><div class="line"><span class="comment">//  int pad2:17;  // padding 17 bits // 4bytes是一个集体,最后没用完的要填充,形成一个完整的4bytes</span></div><div class="line"><span class="comment">//  char pad3;    // padding 8 bits</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// total: 8 bytes</span></div><div class="line">---------------------------------------------------------------</div><div class="line">|    <span class="keyword">short</span>    |  <span class="keyword">char</span>  |<span class="number">1</span>| <span class="number">4</span> |<span class="number">3</span>|   <span class="number">7</span>   |     <span class="number">17</span>      |  <span class="keyword">char</span>  |</div><div class="line">-----------------------|-------|---------------------|--------|</div><div class="line">                        <span class="number">1</span> bytes         <span class="number">3</span> bytes        <span class="number">1</span> bytes</div><div class="line">|------------------------------|------------------------------|</div><div class="line">            <span class="number">4</span> bytes                        <span class="number">4</span> bytes</div><div class="line"></div><div class="line"><span class="keyword">struct</span> foo5_2 &#123;</div><div class="line">    <span class="keyword">short</span> s;      <span class="comment">// 2 bytes</span></div><div class="line">    <span class="keyword">char</span> c;       <span class="comment">// 1 bytes</span></div><div class="line">    <span class="keyword">int</span> flip:<span class="number">2</span>;   <span class="comment">// 2 bits ------------|</span></div><div class="line"><span class="comment">//  int pad1:6;   // padding 6 bits ----| total 1 byte ---|</span></div><div class="line">    <span class="keyword">int</span> nybble:<span class="number">9</span>; <span class="comment">// 9 bits ---|                          |</span></div><div class="line"><span class="comment">//  int pad2:7;   // ----------| total 2 bytes -----------|        </span></div><div class="line"><span class="comment">//  int pad3:8;   // ----------| total 1 byte ------------| total 4 bytes (int)</span></div><div class="line"><span class="comment">//  int pad4:8;   // padding total 23 bits</span></div><div class="line">    <span class="keyword">int</span> bb;</div><div class="line">    <span class="keyword">int</span> septet:<span class="number">7</span>; <span class="comment">// 7 bits</span></div><div class="line"><span class="comment">//  int pad5:1;   // 1 its</span></div><div class="line">    <span class="keyword">char</span> dd;</div><div class="line"><span class="comment">//  char pad6[2]; // 2 bytes</span></div><div class="line">&#125;; <span class="comment">// length =  8 bytes</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> foo6 &#123;</div><div class="line">    <span class="keyword">int</span> a:<span class="number">5</span>; <span class="comment">// 5 bits</span></div><div class="line">    <span class="keyword">int</span> b:<span class="number">3</span>; <span class="comment">// 8 bits</span></div><div class="line"><span class="comment">//  int pad:24; // padding 24 bits</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// total: 4 bytes</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> foo7 &#123;</div><div class="line">    <span class="keyword">int</span> a:<span class="number">30</span>; <span class="comment">// total 30 bits</span></div><div class="line"><span class="comment">//  int pad1:2; // 填充2个</span></div><div class="line">    <span class="keyword">int</span> b:<span class="number">3</span>;  <span class="comment">// total 33 bits &gt; 32 bits装不下，所以从新的字（int）开始</span></div><div class="line"><span class="comment">//  int pad2:29;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于内存对齐的存在,我们在设计结构体或者C++的类时(C++中的结构体和类也有内存对齐), 就需要细心了. 比如下面的foo8占用24bytes, 但是通过调整成员顺序得到foo9, 它的内存占用就变为了16bytes, 这是多么客观!<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> foo8 &#123;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"><span class="comment">//  char pad1[7];     // padding 7 bytes aligning to p;     </span></div><div class="line">    <span class="keyword">struct</span> foo8 *p;</div><div class="line">    <span class="keyword">short</span> x;</div><div class="line"><span class="comment">//  char pad2[6];    // padding 6 bytes aligning to boundary    </span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// sizeof(foo8) = 24</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> foo9 &#123;</div><div class="line">    <span class="keyword">struct</span> foo9 *p;</div><div class="line">    <span class="keyword">short</span> x;</div><div class="line">    <span class="keyword">char</span> c;</div><div class="line"><span class="comment">//  char pad[5];   // padding 5 bytes aligning to boundary </span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// sizeof(foo8) = 16</span></div></pre></td></tr></table></figure></p>
<p>详细的结构体内存对齐知识,可以研读<a href="https://github.com/lixinyancici/The-Lost-Art-of-C-Structure-Packing" target="_blank" rel="external">失传的C结构体打包技艺</a>,这是我从ludx那fork过来的,不是我翻译的,里面有原文链接, 另外clang编译器有个-Wpadded参数,加上它就会在编译输出信息中以警告的形式输出有关内存对齐的信息.</p>
<h4 id="3-结构体中的匿名成员"><a href="#3-结构体中的匿名成员" class="headerlink" title="3. 结构体中的匿名成员"></a>3. 结构体中的匿名成员</h4><p>结构体中的匿名联合体或者结构体的成员,可以当做该结构体成员来访问,但是非匿名的就不能直接当成成员访问了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> VarEnum &#123;</div><div class="line">    T_EMPTY = <span class="number">0</span>,</div><div class="line">    T_DOUBLE = <span class="number">1</span></div><div class="line">&#125;; <span class="comment">// 4 bytes</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> VT_VARIENT &#123;</div><div class="line">    <span class="keyword">enum</span> VarEnum varType;</div><div class="line"><span class="comment">//    char pad[4]; // 填充空间，浪费掉</span></div><div class="line">    <span class="keyword">union</span> &#123; <span class="comment">// 结构体中的匿名联合体，可以当做结构体的成员来访问，</span></div><div class="line">            <span class="comment">// 但是如果不是匿名的，则不能这样！！</span></div><div class="line">        <span class="keyword">double</span> dbVal;</div><div class="line">        <span class="keyword">int</span> nVal;</div><div class="line">        <span class="keyword">int</span> boolVal:<span class="number">1</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;; <span class="comment">// 16 bytes</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> ParamValue &#123;</div><div class="line">    <span class="keyword">char</span> name; <span class="comment">// 10 bytes</span></div><div class="line">    <span class="keyword">char</span> pad[<span class="number">7</span>]; <span class="comment">// 填充空间,浪费掉</span></div><div class="line">    <span class="keyword">struct</span> VT_VARIENT value;</div><div class="line">    <span class="keyword">struct</span> &#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">char</span> ch;</div><div class="line">    &#125;;</div><div class="line">&#125;; <span class="comment">// 24 bytes</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 结构体可以这样初始化，如果是按顺序来，可以不加.var这样的成员名字</span></div><div class="line">    <span class="keyword">struct</span> ParamValue dstY = &#123;.name = <span class="string">'l'</span>, .value = &#123;.varType = T_EMPTY, .nVal = <span class="number">0</span>&#125;, .i = <span class="number">100</span>, .ch = <span class="string">'A'</span>&#125;;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %c\n"</span>, dstY.i, dstY.ch);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dstY.value.nVal);</div><div class="line">    dstY.value.nVal = <span class="number">10</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dstY.value.nVal);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(enum VarEnum) = %lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">enum</span> VarEnum));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(struct VT_VARIENT) = %lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> VT_VARIENT));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(struct ParamValue) = %lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ParamValue));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(double) = %lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-union"><a href="#4-union" class="headerlink" title="4. union"></a>4. union</h4><ul>
<li>所有成员共享一块内存空间,同一时间只能存储其中的一个数据成员,所有的数据成员具有相同的起始地址(等于union的起始地址);</li>
<li>union所占字节数等于其最大成员所占字节数;</li>
<li>用union检测大小端(big_endian,little_endian):<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEndian</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">union</span> un_ &#123;</div><div class="line">        <span class="keyword">short</span> sh;</div><div class="line">        <span class="keyword">char</span> ch;</div><div class="line">    &#125; check;</div><div class="line"></div><div class="line">    check.sh = <span class="number">0x01</span>;</div><div class="line">    <span class="keyword">if</span> (check.ch == <span class="number">0x01</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注: 大端模式和小端模式：<br>几乎所有的机器上，多字节对象都被存储为连续的字节序列，例如C语言中，int型变量x的地址为0x100，则&amp;x=0x100，这个0x100是指int所占的四个字节中地址最低的那个字节的内存地址（基址），与内存增长顺序无关。也就是说，x的四个字节将被存储在存储器的0x100,0x101,0x102,0x103的位置<br>而存储地址内的排列则有两种通用规则：大端模式和小端模式<br>大端：低地址存高字节<br>小端：低地址存低字节</p>
</blockquote>
<h4 id="3-enum-枚举-是个好东西"><a href="#3-enum-枚举-是个好东西" class="headerlink" title="3. enum(枚举,是个好东西)"></a>3. enum(枚举,是个好东西)</h4><ul>
<li>枚举的成员称为枚举常量,枚举常量的值只能取整型值,不能是浮点值;</li>
<li>枚举里面的成员是<strong>可以</strong>取到的值,跟int变量可以取… -2 -1 0 1 2 …一样, 所以sizeof一个enum的结果是4,因为默认成员是int类型;</li>
<li><strong>注意:</strong> struct,union成员都是用分号”;”分割,而enum是用逗号”,”分割的; struct,class,union,enum的{}后面要加”;”。</li>
<li>用enum标示插件或者选项:<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> flag_ &#123;</div><div class="line">    ATE   = <span class="number">0x00000001</span>;</div><div class="line">    APP   = <span class="number">0x00000002</span>;</div><div class="line">    IN    = <span class="number">0x00000004</span>;</div><div class="line">    OUT   = <span class="number">0x00000008</span>;</div><div class="line">    BIN   = <span class="number">0x00000016</span>;</div><div class="line">    TRUNC = <span class="number">0x00000032</span>;</div><div class="line">&#125; flag;</div><div class="line">...</div><div class="line">flag option = OUT | ATE | BIN;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> flag option)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (option &amp; ATE == ATE) &#123; <span class="comment">// 设置了此选项</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (option &amp; APP == APP) &#123; <span class="comment">// 设置了此选项</span></div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">// 同样的,插件系统中也可以用enum标示哪些插件启用了,哪些没启用,启用一个就按位或(|)上对应标识,关闭一个就按位与(&amp;)上对应标识的按位取反(~)</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><ul>
<li>default语句不应省略,而且要用来处理真正的默认情况(或者未定义的行为);</li>
<li>case 后面只能是整型或字符型的常量或常量表达式,const变量不可以;</li>
<li>多重循环中,尽可能将长循环放在外层,最短的放最内层;</li>
<li>函数如果无参数,应当显示用void指明;</li>
<li>所有函数都应该显示给出返回值,不应以来编译器特性(构造,析构除外).</li>
</ul>
<h3 id="typedef-给已经存在的类型起别名"><a href="#typedef-给已经存在的类型起别名" class="headerlink" title="typedef(给已经存在的类型起别名)"></a>typedef(给已经存在的类型起别名)</h3><h4 id="1-typedef与类型限定符const"><a href="#1-typedef与类型限定符const" class="headerlink" title="1. typedef与类型限定符const"></a>1. typedef与类型限定符const</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> student</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Code</span></div><div class="line">&#125; student_st, *student_pst;</div><div class="line">...</div><div class="line">student_st stu1; <span class="comment">// &lt;=&gt; struct student stu;</span></div><div class="line">student_pst stu2; <span class="comment">// &lt;=&gt; struct student *stu &lt;=&gt; student_st *stu;</span></div><div class="line"><span class="keyword">const</span> student_pst stu3; <span class="comment">// =&gt; const stu3, 对于编译器来说,student_pst就是个类型说明符, 我们分析的时候直接去掉就行,跟int等一样.</span></div><div class="line">student_pst <span class="keyword">const</span> stu4; <span class="comment">// =&gt; const stu4</span></div></pre></td></tr></table></figure>
<h4 id="2-typedef与-define"><a href="#2-typedef与-define" class="headerlink" title="2. typedef与#define"></a>2. typedef与#define</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INT32 int</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> INT64;</div><div class="line"><span class="keyword">unsigned</span> INT32 i = <span class="number">10</span>; <span class="comment">// no problem</span></div><div class="line"><span class="keyword">unsigned</span> INT64 j = <span class="number">10</span>; <span class="comment">// 不行, typedef的类型不支持用类型修饰符进行扩展</span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PCHAR char*</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* PCHAR2;</div><div class="line">PCHAR p1, p2; <span class="comment">// =&gt; char* p1, p2 =&gt; p2不是指针,是char变量</span></div><div class="line">PCHAR2 p3, p4; <span class="comment">// p3, p4都是指针,typedef定义的就是数据类型,与int等的地位用法是一样的.</span></div></pre></td></tr></table></figure>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><p>sizeof()求值是在编译期, 所以类似如下代码是没问题的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">size_t</span> size_a = <span class="keyword">sizeof</span>(a[<span class="number">15</span>]); <span class="comment">// &lt;=&gt; sizeof(int)</span></div></pre></td></tr></table></figure></p>
<p>但是如果通过函数而不是sizeof()来使用a[15]就会出问题,因为函数是运行期执行的,运行期a[15]明越界了.</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释(/**/ //)"></a>注释(/**/ //)</h3><h4 id="1-预处理时-编译器会使用空格替换-所以"><a href="#1-预处理时-编译器会使用空格替换-所以" class="headerlink" title="1. /* */ 预处理时,编译器会使用空格替换,所以"></a>1. /* */ 预处理时,编译器会使用空格替换,所以</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">in<span class="comment">/*...*/</span>t i = <span class="number">0</span>; <span class="comment">// 是错误的, gcc -E 编译后变成 in t i = 0;</span></div></pre></td></tr></table></figure>
<h4 id="2-y-x-p-不等于-y-x-p"><a href="#2-y-x-p-不等于-y-x-p" class="headerlink" title="2. y = x / *p 不等于 y = x/*p,"></a>2. y = x / *p 不等于 y = x/*p,</h4><p>因为编译器解析语法的时候,是从左到右,找最长的有意义的单元,对于第二段代码,编译器找到x后继续往后找,判断’x/‘是否是合法的标识符或者关键字,发现不是,于是记录下’x’,<br>然后从’/‘开始找,继续向下找,判断’/<em>‘是否是有意义的符号,发现是,他是注释的开始,但不会停止,编译器继续往下找,判断’/\</em>p’是不是有意义的符号,发现不是,于是记下’/*‘,<br>再从’p’开始, … ,<br>所以第二段语句是错误的,因为解析出来了’/*‘但没解析出*/,无法配对,所以报错.</p>
<h3 id="逻辑运算符-amp-amp"><a href="#逻辑运算符-amp-amp" class="headerlink" title="逻辑运算符(|| &amp;&amp;)"></a>逻辑运算符(|| &amp;&amp;)</h3><h4 id="1-存在短路现象"><a href="#1-存在短路现象" class="headerlink" title="1. 存在短路现象:"></a>1. 存在短路现象:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> ((++i &gt; <span class="number">0</span>) || (++j &gt; <span class="number">0</span>)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d, j = %d"</span>, i, j);</div><div class="line">&#125;</div><div class="line"><span class="comment">// i = 1, j = 0</span></div></pre></td></tr></table></figure>
<p>或运算: 从左到右,发现值大于0的条件后,后面的条件不会再计算;<br>与运算: 从左到右,发现值等于0的条件后,后面的条件不会再计算。</p>
<h3 id="位运算符-amp-lt-lt-gt-gt"><a href="#位运算符-amp-lt-lt-gt-gt" class="headerlink" title="位运算符(| &amp; ~ ^ &lt;&lt; &gt;&gt;)"></a>位运算符(| &amp; ~ ^ &lt;&lt; &gt;&gt;)</h3><ul>
<li>&lt;&lt; 左操作数的各个二进制为向左边移动右操作数个位值,高位丢弃,低位补零;</li>
<li>>&gt; 左操作数的各个二进制为向右边移动右操作数个位值，无符号数，高位补零，有符号数，高位补符号位的数值（正数为０，负数为１）；</li>
<li>&lt;&lt; &gt;&gt; 的位数不能大于数据长度，不能小于０。</li>
</ul>
<h3 id="自增自减运算符-–"><a href="#自增自减运算符-–" class="headerlink" title="自增自减运算符(++ –)"></a>自增自减运算符(++ –)</h3><h4 id="1-C中的计算单位"><a href="#1-C中的计算单位" class="headerlink" title="1. C中的计算单位:"></a>1. C中的计算单位:</h4><ul>
<li>逗号表达式中,每一个”逗号(,)”,都表示一个计算单位的结束;</li>
<li>for循环中,中间的条件表达式计算完成之后,表示一个计算单位结束;</li>
<li>“分号(;)”表示一个计算单位结束。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> j = (i\++, i\++, i\++); <span class="comment">// 逗号表达式，i每遇到一个逗号就认为本计算单元结束，自加</span></div><div class="line"><span class="keyword">int</span> y;</div><div class="line"><span class="comment">//每次y与10比较完，不管比较结果，Y就认为本计算单元结束，自加，不是&#123;&#125;里的算完就马上加。</span></div><div class="line"><span class="keyword">for</span> ( y = <span class="number">0</span>; y &lt; <span class="number">10</span>; y\++) </div><div class="line">&#123;</div><div class="line">	<span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">i = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> k = (i\++) + (i\++) + (i\++); <span class="comment">// i遇到；认为本次计算单元结束，把累积的三次自加全部执行一次，为6</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-var-var–计算单位结束后才会进行自增或者自减操作"><a href="#2-var-var–计算单位结束后才会进行自增或者自减操作" class="headerlink" title="2. var++,var–计算单位结束后才会进行自增或者自减操作."></a>2. var++,var–<strong>计算单位</strong>结束后才会进行自增或者自减操作.</h4><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><h4 id="1-运算符优先级表"><a href="#1-运算符优先级表" class="headerlink" title="1. 运算符优先级表"></a>1. 运算符优先级表</h4><div align="center"><br><img src="./运算符.png" alt=""><br></div>

<h4 id="2-易错点"><a href="#2-易错点" class="headerlink" title="2. 易错点:"></a>2. 易错点:</h4><p>(copy自<a href="http://c.biancheng.net/cpp/html/462.html" target="_blank" rel="external">C语言中文网</a>)</p>
<div align="center"><br><img src="C:/Users/StarrySky/Desktop/预处理易错点.jpg" alt="op_tab"><br></div>

<h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符(\)"></a>连接符(\)</h3><p>反斜杠作为连接符时,后面不能有任何字符,即使空格也不行.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"This is \</span></div><div class="line">  perfect!\n");</div><div class="line"><span class="comment">// 连接符后面不能加空格。</span></div><div class="line"><span class="comment">// 连接符下一行中如果前面为了对齐使用了空格，空格会被当做有效字符。</span></div><div class="line"><span class="comment">// 输出: This is   perfect!</span></div></pre></td></tr></table></figure></p>
<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令:"></a>预处理指令:</h3><h4 id="1-预处理指令表"><a href="#1-预处理指令表" class="headerlink" title="1. 预处理指令表"></a>1. 预处理指令表</h4><p>(copy自<a href="http://c.biancheng.net/cpp/html/463.html" target="_blank" rel="external">C语言中文网</a>)</p>
<div align="center"><br><img src="预处理指令1.jpg" alt=""><br><img src="预处理指令2.jpg" alt="pre-process2"><br></div>

<h4 id="2-ASCII-C-定义的宏"><a href="#2-ASCII-C-定义的宏" class="headerlink" title="2. ASCII C 定义的宏:"></a>2. ASCII C 定义的宏:</h4><p>_LINE_: 正在编译的文件的行号<br>_FILE_: 正在编译的文件名<br>_DATE_: 编译时刻的日期字符串 “25 Dec 2017”<br>_TIME_: 编译时刻的时间字符串 “12:30:58”</p>
<h3 id="宏定义-define-undef"><a href="#宏定义-define-undef" class="headerlink" title="宏定义(#define #undef)"></a>宏定义(#define #undef)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x) ((x)+(x)) <span class="comment">// no problem</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM (x) ((x)+(x)) <span class="comment">// 错误,SUM后不该有空格</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TOCHAR(x) #x     <span class="comment">// # -&gt; 转化为字符</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR(x,y) x##y    <span class="comment">// ## -&gt; 合并</span></span></div></pre></td></tr></table></figure>
<h3 id="pragma预处理"><a href="#pragma预处理" class="headerlink" title="#pragma预处理"></a>#pragma预处理</h3><p>用于设定编译器状态或者只是编译器完成一些特定动作</p>
<h4 id="1-pragma-message-“文本”"><a href="#1-pragma-message-“文本”" class="headerlink" title="1. #pragma message(“文本”)"></a>1. #pragma message(“文本”)</h4><p>在编译信息输出窗口输出相应的”文本”信息.</p>
<h4 id="2-pragma-once"><a href="#2-pragma-once" class="headerlink" title="2. #pragma once"></a>2. #pragma once</h4><p>保证头文件只被变编译一次,防止头文件的重复包含.</p>
<h4 id="3-pragma-warning-…"><a href="#3-pragma-warning-…" class="headerlink" title="3. #pragma warning(…)"></a>3. #pragma warning(…)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:405034; once: 4366; <span class="meta-keyword">error</span>: 164)</span></div><div class="line"><span class="comment">// disable: 不显示对应的警告</span></div><div class="line"><span class="comment">// once: 对应警告只显示一次</span></div><div class="line"><span class="comment">// error: 将对应警告当做错误处理</span></div></pre></td></tr></table></figure>
<h4 id="4-pragma-pack-n"><a href="#4-pragma-pack-n" class="headerlink" title="4. #pragma pack(n)"></a>4. #pragma pack(n)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(8) <span class="comment">// 设置字节对齐方式位8字节对齐</span></span></div><div class="line">...</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack() <span class="comment">// 取消自定义的字节对齐方式</span></span></div></pre></td></tr></table></figure>
<p>注: 这里用<figure class="highlight plain"><figcaption><span>pack(8)```设置的8,只是一个最大值,实际对齐的字节数为:min(成员中所占字节最大值, 8):</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">```C</div><div class="line">struct Test</div><div class="line">&#123;</div><div class="line">    int i;    // 4 bytes</div><div class="line">    char [2]; // 2 bytes</div><div class="line"> // char pad[2]; // 编译器填充两个字节</div><div class="line">    float f;  // 4 bytes</div><div class="line">&#125;</div><div class="line">// 该结构体的大小位12bytes, 它是4字节对齐,因为min(4,8)=4.</div></pre></td></tr></table></figure></p>
<h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针就是一个变量</strong>, 只不过这个变量的值,是一个内存地址而已.</p>
<ul>
<li>指针变量 加/减 整数，所表达的含义是：相对当前指针值的偏移，偏移量为:  整数*指针指向的数据类型的大小</li>
<li>void <em>类型的指针，偏移时是以字节为单位的，同char </em>（gcc）</li>
<li>相同类型的指针 相减，所表达的含义是: 这两个指针之间的偏移量(元素的个数) &lt;=&gt; <figure class="highlight plain"><figcaption><span>/ sizeof(data_type)```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* 相同类型的指针不能进行 相加 运算</div><div class="line">* 不同类型的指针不能进行算数运算</div><div class="line"></div><div class="line">### 函数指针</div><div class="line">#### 1. 函数指针</div><div class="line">函数与变量/常量一样,也要存储与内存中,只不过变量/常量存的是数据,而函数存的是逻辑或者叫算法,之前说过,凡是内存中的东西,都可以通过指针访问(当然这只是理论上),那函数也不例外,也可以通过指针来访问,指向函数的指针成为函数指针,函数名称就代表函数的地址,当然也可以对函数名取地址,二者效果相同, 即```func() =&gt; func &lt;=&gt; &amp;func```.</div><div class="line">```C</div><div class="line">char *func(const char* ch1, const char* ch2); // 声明一个函数</div><div class="line">char (*pfunc)(const char* ch1, const char* ch2); // 定义一个函数指针</div></pre></td></tr></table></figure></li>
</ul>
<p>上面的代码中,func是一个返回字符指针的函数, 而pfunc是一个返回字符的函数指针,二者的形参列表是相同的.</p>
<h4 id="2-函数指针数组"><a href="#2-函数指针数组" class="headerlink" title="2. 函数指针数组"></a>2. 函数指针数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></div><div class="line"><span class="keyword">char</span>* pdata[N];</div><div class="line"><span class="keyword">char</span>* (*pfunc[N])(<span class="keyword">const</span> <span class="keyword">char</span> *p); <span class="comment">// &lt;=&gt; char* (*)(const char *p) pfunc[N];</span></div><div class="line"><span class="comment">//                                      |-----------------------|</span></div><div class="line">                                                函数指针类型</div></pre></td></tr></table></figure>
<p>上面的代码定义了一个函数指针数组,跟指针数组没什么区别,只不过指针数组里的元素指向的是数据,而函数指针数组里面的元素指向的是函数而已,但就数组本身而言,二者是完全一样的,N一定,二者大小都一样.</p>
<p>既然是数组,当然也可以定义函数指针数组的指针, 与普通数组指针没啥区别:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></div><div class="line"><span class="keyword">char</span>* (*pdata)[N];</div><div class="line"><span class="keyword">char</span>* (*(*pfunc)[N])(<span class="keyword">const</span> <span class="keyword">char</span> *p); <span class="comment">// &lt;=&gt; char* (*)(const char *p) (*pfunc)[N];</span></div></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="1-数组名的含义"><a href="#1-数组名的含义" class="headerlink" title="1. 数组名的含义"></a>1. 数组名的含义</h4><p>数组名不能作为左值(放在赋值运算符左边), 作为右值时代表的是数组首元素地址,  但sizeof(数组名)的结果是整个数组的大小,因为此处数组名不是右值;<br>如下例中, a是数组名(<strong>代表</strong>数组首元素的地址), 而&amp;a的含义是数组的地址, 它们在值上是相等的,因为数组首元素相对于整个数组来说,它的偏移是0,所以在内存中数组的地址等于数组首元素的地址; 但是它们两个的含义完全不同,通过取值就能看出, <em>(&amp;a) 是地址,等同与数组名a, 而</em>a是一个值,是首元素的值.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"a = %p\n"</span>, (<span class="keyword">void</span>*)(a));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a[0] = %p\n"</span>, (<span class="keyword">void</span>*)(&amp;a[<span class="number">0</span>]));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;a = %p\n"</span>, (<span class="keyword">void</span>*)&amp;a);</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"*a = %d\n"</span>, *a);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;a[0] = %d\n"</span>, *&amp;a[<span class="number">0</span>]);</div><div class="line"><span class="comment">// 返回的是地址i，其值与&amp;a[0]、a相同，但含义不同，代表整个数组的首地址</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"*&amp;a = %p\n"</span>, (<span class="keyword">void</span>*)(*&amp;a));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(*a) = %lu\n"</span>, <span class="keyword">sizeof</span>(*a));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(*&amp;a[0]) = %lu\n"</span>, <span class="keyword">sizeof</span>(*&amp;a[<span class="number">0</span>]));</div><div class="line"><span class="comment">// &amp;a代表的是整个数组的首地址，作为右值代表的数组首元素的地址\n</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(*&amp;a) = %lu"</span>, <span class="keyword">sizeof</span>(*&amp;a));</div><div class="line"></div><div class="line">*a = <span class="number">11</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"a[0] = %d\n"</span>, a[<span class="number">0</span>]);</div><div class="line"></div><div class="line"><span class="comment">// OUT :</span></div><div class="line"><span class="comment">// a = 0x7ffc336df2a0</span></div><div class="line"><span class="comment">// &amp;a[0] = 0x7ffc336df2a0</span></div><div class="line"><span class="comment">// &amp;a = 0x7ffc336df2a0</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// *a = 1</span></div><div class="line"><span class="comment">// *&amp;a[0] = 1</span></div><div class="line"><span class="comment">// *&amp;a = 0x7ffc336df2a0</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// sizeof(*a) = 4</span></div><div class="line"><span class="comment">// sizeof(*&amp;a[0]) = 4</span></div><div class="line"><span class="comment">// sizeof(*&amp;a) = 20a[0] = 11</span></div></pre></td></tr></table></figure></p>
<h4 id="2-数组与指针"><a href="#2-数组与指针" class="headerlink" title="2. 数组与指针"></a>2. 数组与指针</h4><p><strong>它们没有任何关系, 只是有相似的使用方式而已.</strong><br>虽然前面我们说数组名代表首元素的地址, 但只是代表而已, 实际上并没有a这么一个变量,里面存着数组有元素的地址.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[] = <span class="string">"pointer vs array"</span>;</div><div class="line"><span class="keyword">char</span> *p = <span class="string">"pointer vs array"</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lu, %lu\n"</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(p));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(&amp;a));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%lu, %lu\n"</span>, <span class="keyword">sizeof</span>(*(&amp;a)), <span class="keyword">sizeof</span>(*p));</div><div class="line"></div><div class="line"><span class="comment">// OUT:</span></div><div class="line"><span class="comment">// 17, 8</span></div><div class="line"><span class="comment">// 8</span></div><div class="line"><span class="comment">// 17, 8</span></div></pre></td></tr></table></figure></p>
<p>由上例可以看出, a显然不是指针,因为指针变量的大小是8, 而&amp;a才是实实在在的指向数组的指针;<br>另外<em>(&amp;a)与</em>p也是完全不同的, <em>(&amp;a)表示的是整个数组, 而</em>p只是代表一个字符而已;<br>只要是存在与内存中的数据，都能通过指针来访问，数组也是存在于内存中的数据，所以它也可以通过指针(利用基址＋偏移地址方式)来访问, 就跟用指针访问基本数据一样, 只是恰好Ｃ语言支持指针通过下表来操作, 同时数组支持通过偏移的形式来操作, 所以看起来指针与数组比较像而已.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[] = <span class="string">"pointer vs array"</span>;</div><div class="line"><span class="keyword">char</span> *p = <span class="string">"pointer vs array"</span>;</div><div class="line"><span class="keyword">char</span> tmp1 = a[<span class="number">0</span>]; <span class="comment">// &lt;=&gt; *((char*)&amp;a + 0)</span></div><div class="line"><span class="keyword">char</span> tmp2 = p[<span class="number">0</span>]; <span class="comment">// &lt;=&gt; *(p + 0)</span></div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-------栈--------|------|-----堆/静态区---------</div><div class="line">    |-----|      |      |</div><div class="line">    |-----|      |      |</div><div class="line">  a | ... |      |      |</div><div class="line">    |-----|      |      |</div><div class="line">    |-----|      |      |</div><div class="line">    |-----|      |      |</div><div class="line">                 |      |</div><div class="line">    |  p  |------|------|----&gt;|-----| </div><div class="line">                 |      |     |-----|</div><div class="line">                 |      |     | ... |</div><div class="line">                 |      |     |-----|</div><div class="line">                 |      |     |-----|</div><div class="line">                 |      |     |-----|           </div><div class="line">-----------------|------|-----------------------</div></pre></td></tr></table></figure>
<p>编译器总是把基于下标的操作解析为基于’基址+偏移’的操作方式, 汇编就是这么干的.</p>
<h4 id="3-基址-偏移方式访问数组元素问题"><a href="#3-基址-偏移方式访问数组元素问题" class="headerlink" title="3. 基址+偏移方式访问数组元素问题"></a>3. <strong>基址+偏移方式访问数组元素问题</strong></h4><p>直接看下面的例子即可, ptr3这种情况需要特别注意:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line"><span class="comment">// &amp;a指向数组的指针，+1就是偏移一个数组的大小，现在它指向a[5]下面紧邻的那个</span></div><div class="line"><span class="comment">// 5×sizeof(int)的区域（未定义区域）。本来是指向数组的指针，值为数组首元素</span></div><div class="line"><span class="comment">// 的地址，强制转换成int*后就是指向一个int值的指针了，此时*ptr1是一个int值</span></div><div class="line"><span class="keyword">int</span> *ptr1 = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// a是数组名，指向数组首元素，是一个int*，对它加1，就是向后偏移sizeof(int)</span></div><div class="line"><span class="comment">// 个字节，指向数组第二个元素,其实这里的强制类型转换是多余的，但写上会使概念更清晰。</span></div><div class="line"><span class="keyword">int</span> *ptr2 = (<span class="keyword">int</span>*)((<span class="keyword">int</span>*)a + <span class="number">1</span>); <span class="comment">// &lt;=&gt; a + 1</span></div><div class="line"></div><div class="line"><span class="comment">// 转换成标量, +4就是+4bytes, 指向第二个元素</span></div><div class="line"><span class="keyword">int</span> *ptr3 = (<span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)a + <span class="number">4</span>); </div><div class="line"></div><div class="line"><span class="comment">// ptr1是一个指向int的指针, 它目前指向数组a最后一个元素后面紧跟的那个地址, </span></div><div class="line"><span class="comment">// ptr1[-1]就是向前偏移sizeof(int)bytes, 也就是a的最后一个元素.</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%x, %x, %x\n"</span>, ptr1[<span class="number">-1</span>], *ptr2, *ptr3);</div><div class="line"></div><div class="line"><span class="comment">// OUT</span></div><div class="line"><span class="comment">// 5, 2, 2</span></div></pre></td></tr></table></figure></p>
<h4 id="4-数组指针与指针数组"><a href="#4-数组指针与指针数组" class="headerlink" title="4. 数组指针与指针数组"></a>4. 数组指针与指针数组</h4><figure class="highlight plain"><figcaption><span>(\*p)[]``` => 数组指针, p是指向数组的指针, 有一点需要注意, 此时\*p跟数组名同义, 代表数组首元素地址,所以\*\*p就是一个int型变量,大小为4bytes;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">```int \*p[]``` =&gt; []小标运算符的优先级高于\*, 所以等价于int\* (p[]), 首先p是一个数组, 数组元素的类型是int\*, 即指针数组.</div><div class="line">```C</div><div class="line">int a[5] = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line"></div><div class="line">// 指针数组与数组指针</div><div class="line">int (*p)[5] = &amp;a; // p是个指针</div><div class="line">// pp是一个数组，数组元素是int型指针</div><div class="line">int *pp[5] = &#123;NULL, NULL, NULL, NULL, NULL&#125;;</div><div class="line">// p是指针，大小是8bytes</div><div class="line">printf(&quot;sizeof(p) = %lu\n&quot;, sizeof(p));</div><div class="line">// *p是p所指向的数组,它等效于数组名</div><div class="line">printf(&quot;sizeof(*p) = %lu\n&quot;, sizeof(*p));</div><div class="line">// **p是p所指向数组的第一个元素4bytes</div><div class="line">printf(&quot;sizeof(**p) = %lu\n&quot;, sizeof(**p));</div><div class="line"></div><div class="line">printf(&quot;sizeof(pp) = %lu\n&quot;, sizeof(pp));</div><div class="line">printf(&quot;sizeof(*pp) = %lu\n\n&quot;, sizeof(*pp));</div><div class="line"></div><div class="line">// 等效于数组名</div><div class="line">printf(&quot;*p = %p\n&quot;, (void *)(*p)); </div><div class="line">// 数组名代表数组首元素的地址，这里只是偏移sizeof(int)</div><div class="line">printf(&quot;*p+1 = %p\n\n&quot;, (void *)(*p+1));</div><div class="line"></div><div class="line">// OUT:</div><div class="line">// sizeof(p) = 8</div><div class="line">// sizeof(*p) = 20</div><div class="line">// sizeof(**p) = 4</div><div class="line">//</div><div class="line">// sizeof(pp) = 40</div><div class="line">// sizeof(*pp) = 8</div><div class="line">// </div><div class="line">// *p = 0x7fff90402500</div><div class="line">// *p+1 = 0x7fff90402504</div></pre></td></tr></table></figure>
<h4 id="5-数组作为函数参数"><a href="#5-数组作为函数参数" class="headerlink" title="5. 数组作为函数参数"></a>5. 数组作为函数参数</h4><p>一维数组作为函数参数, 编译器会把它处理成指针:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">char</span> text[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(text)); <span class="comment">// 输出始终为8, 不论传什么进来</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="6-多维数组"><a href="#6-多维数组" class="headerlink" title="6. 多维数组"></a>6. 多维数组</h4><p>一维数组作为函数参数, 编译器会把它处理成指针, 但这个过程不是递归的, 也就是说只有一维数组才会这样, 当数组超过一维时, 将第一维改写为指向数组的指针后,后面的维再也不可改写:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void func1(char a[][4]) &#123;</div><div class="line">   // code</div><div class="line">&#125;</div><div class="line">// 两个函数等价</div><div class="line">void func2(char (*p)[4]) &#123;</div><div class="line">    // code</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二维数组做参数第一维的维度可以省略，但第二维的不行, 因为它标示了第一维的指针指向数据的类型.<br>有个小陷阱要注意:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;&#125;; <span class="comment">// 二维数组赋值</span></div><div class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">2</span>] = &#123;(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 注意里面不是中括号是逗号表达式 &lt;=&gt; &#123;1, 3, 5&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> *p1, *p2;</div><div class="line">p1= a[<span class="number">0</span>];</div><div class="line">p2 = b[<span class="number">0</span>];</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, p1[<span class="number">0</span>], p2[<span class="number">0</span>]);</div><div class="line"></div><div class="line"><span class="comment">// OUT:</span></div><div class="line"><span class="comment">// 0, 1</span></div></pre></td></tr></table></figure></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="linux程序内存模型"><a href="#linux程序内存模型" class="headerlink" title="linux程序内存模型:"></a>linux程序内存模型:</h3><p>每一个进程都有一个大小与物理内存相同的虚拟内存空间, 然后具体用时映射到物理内存, 因为有虚拟内存空间的存在, 所以编译器和连接器可以在编译或链接时直接分配内存地址, 它们分配的是虚拟内存地址.</p>
<p><div align="center"><br><img src="./linux_binary_memory.png" alt=""><br></div></p>
<ul>
<li>用户栈: 局部自动变量,函数栈等,向低地址生长</li>
<li>运行时堆(动态内存分配区): malloc/new, 向高地址生长</li>
<li>读/写段(静态数据区):<ul>
<li>.data: 已经初始化的全局自动变量和静态变量(全局的和局部的)</li>
<li>.bss: 未初始化的全局自动变量和静态变量(全局的和局部的)</li>
</ul>
</li>
<li>只读段(代码段):<ul>
<li>.text: 存放程序代码</li>
<li>.rodata: 常量区,存储字符串常量,const常量(全局的或者静态的,局部的不在这)<br>所谓的内存管理,其实就是管理”运行时堆”.</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>不使用库函数编写strlen, 但是当str很长时间,这个函数并不实用:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> myStrlen(<span class="keyword">const</span> <span class="keyword">char</span> *str)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (*str != <span class="string">'\0'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> (myStrlen(++str) + <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="StarrySky" />
          <p class="site-author-name" itemprop="name">StarrySky</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/lixinyancici" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/li-xin-yan-73" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  ZhiHu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#补码"><span class="nav-number">1.</span> <span class="nav-text">补码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言32个关键字"><span class="nav-number">2.</span> <span class="nav-text">C语言32个关键字:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据存储类别指示符"><span class="nav-number">2.1.</span> <span class="nav-text">数据存储类别指示符:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-static-静态变量"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. static(静态变量):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-extern-声明其具有外部链接属性-同static相反"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. extern(声明其具有外部链接属性,同static相反):</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型限定符"><span class="nav-number">2.2.</span> <span class="nav-text">类型限定符:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-const-只读变量"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. const(只读变量):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-volatile-关闭优化-让编译器老老实实按语句的意思来编译"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. volatile(关闭优化,让编译器老老实实按语句的意思来编译):</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-结构体中的匿名成员"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 结构体中的匿名成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-union"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-enum-枚举-是个好东西"><span class="nav-number">2.2.5.</span> <span class="nav-text">3. enum(枚举,是个好东西)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制语句"><span class="nav-number">2.3.</span> <span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef-给已经存在的类型起别名"><span class="nav-number">2.4.</span> <span class="nav-text">typedef(给已经存在的类型起别名)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-typedef与类型限定符const"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. typedef与类型限定符const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-typedef与-define"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. typedef与#define</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof"><span class="nav-number">2.5.</span> <span class="nav-text">sizeof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号"><span class="nav-number">3.</span> <span class="nav-text">符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-number">3.1.</span> <span class="nav-text">注释(/**/ //)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-预处理时-编译器会使用空格替换-所以"><span class="nav-number">3.1.1.</span> <span class="nav-text">1. /* */ 预处理时,编译器会使用空格替换,所以</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-y-x-p-不等于-y-x-p"><span class="nav-number">3.1.2.</span> <span class="nav-text">2. y = x / *p 不等于 y = x/*p,</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑运算符-amp-amp"><span class="nav-number">3.2.</span> <span class="nav-text">逻辑运算符(|| &&)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-存在短路现象"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 存在短路现象:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算符-amp-lt-lt-gt-gt"><span class="nav-number">3.3.</span> <span class="nav-text">位运算符(| & ~ ^ << >>)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自增自减运算符-–"><span class="nav-number">3.4.</span> <span class="nav-text">自增自减运算符(++ –)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-C中的计算单位"><span class="nav-number">3.4.1.</span> <span class="nav-text">1. C中的计算单位:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-var-var–计算单位结束后才会进行自增或者自减操作"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. var++,var–计算单位结束后才会进行自增或者自减操作.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符优先级"><span class="nav-number">3.5.</span> <span class="nav-text">运算符优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-运算符优先级表"><span class="nav-number">3.5.1.</span> <span class="nav-text">1. 运算符优先级表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-易错点"><span class="nav-number">3.5.2.</span> <span class="nav-text">2. 易错点:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接符"><span class="nav-number">3.6.</span> <span class="nav-text">连接符(\)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理"><span class="nav-number">4.</span> <span class="nav-text">预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理指令"><span class="nav-number">4.1.</span> <span class="nav-text">预处理指令:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-预处理指令表"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. 预处理指令表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ASCII-C-定义的宏"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. ASCII C 定义的宏:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏定义-define-undef"><span class="nav-number">4.2.</span> <span class="nav-text">宏定义(#define #undef)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pragma预处理"><span class="nav-number">4.3.</span> <span class="nav-text">#pragma预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-pragma-message-“文本”"><span class="nav-number">4.3.1.</span> <span class="nav-text">1. #pragma message(“文本”)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-pragma-once"><span class="nav-number">4.3.2.</span> <span class="nav-text">2. #pragma once</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-pragma-warning-…"><span class="nav-number">4.3.3.</span> <span class="nav-text">3. #pragma warning(…)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-pragma-pack-n"><span class="nav-number">4.3.4.</span> <span class="nav-text">4. #pragma pack(n)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与数组"><span class="nav-number">5.</span> <span class="nav-text">指针与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">5.1.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-函数指针数组"><span class="nav-number">5.1.1.</span> <span class="nav-text">2. 函数指针数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">5.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组名的含义"><span class="nav-number">5.2.1.</span> <span class="nav-text">1. 数组名的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数组与指针"><span class="nav-number">5.2.2.</span> <span class="nav-text">2. 数组与指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-基址-偏移方式访问数组元素问题"><span class="nav-number">5.2.3.</span> <span class="nav-text">3. 基址+偏移方式访问数组元素问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-数组指针与指针数组"><span class="nav-number">5.2.4.</span> <span class="nav-text">4. 数组指针与指针数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组作为函数参数"><span class="nav-number">5.2.5.</span> <span class="nav-text">5. 数组作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-多维数组"><span class="nav-number">5.2.6.</span> <span class="nav-text">6. 多维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">6.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux程序内存模型"><span class="nav-number">6.1.</span> <span class="nav-text">linux程序内存模型:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">7.1.</span> <span class="nav-text">递归</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StarrySky</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  


  

  

</body>
</html>
